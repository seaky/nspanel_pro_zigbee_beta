import { createEslintRule } from '../utils/create-eslint-rule.mjs'
import { getSourceCode } from '../utils/get-source-code.mjs'
import { rangeToDiff } from '../utils/range-to-diff.mjs'
import { isPositive } from '../utils/is-positive.mjs'
import { makeFixes } from '../utils/make-fixes.mjs'
import { sortNodes } from '../utils/sort-nodes.mjs'
import { pairwise } from '../utils/pairwise.mjs'
import { complete } from '../utils/complete.mjs'
import { compare } from '../utils/compare.mjs'
const sortSwitchCase = createEslintRule({
  name: 'sort-switch-case',
  meta: {
    type: 'suggestion',
    docs: {
      description: 'Enforce sorted switch cases.',
    },
    fixable: 'code',
    schema: [
      {
        type: 'object',
        properties: {
          type: {
            description: 'Specifies the sorting method.',
            type: 'string',
            enum: ['alphabetical', 'natural', 'line-length'],
          },
          order: {
            description:
              'Determines whether the sorted items should be in ascending or descending order.',
            type: 'string',
            enum: ['asc', 'desc'],
          },
          ignoreCase: {
            description:
              'Controls whether sorting should be case-sensitive or not.',
            type: 'boolean',
          },
        },
        additionalProperties: false,
      },
    ],
    messages: {
      unexpectedSwitchCaseOrder:
        'Expected "{{right}}" to come before "{{left}}".',
    },
  },
  defaultOptions: [
    {
      type: 'alphabetical',
      order: 'asc',
      ignoreCase: true,
    },
  ],
  create: context => ({
    SwitchStatement: node => {
      let options = complete(context.options.at(0), {
        type: 'alphabetical',
        ignoreCase: true,
        order: 'asc',
      })
      let sourceCode = getSourceCode(context)
      let isDiscriminantIdentifier = node.discriminant.type === 'Identifier'
      let isCasesHasBreak = node.cases
        .filter(caseNode => caseNode.test !== null)
        .every(
          caseNode =>
            caseNode.consequent.length === 0 ||
            caseNode.consequent.some(
              currentConsequent =>
                currentConsequent.type === 'BreakStatement' ||
                currentConsequent.type === 'ReturnStatement',
            ),
        )
      if (isDiscriminantIdentifier && isCasesHasBreak) {
        let nodes = node.cases.map(caseNode => {
          var _a, _b
          let name
          if (((_a = caseNode.test) == null ? void 0 : _a.type) === 'Literal') {
            name = `${caseNode.test.value}`
          } else {
            name = 'default'
          }
          return {
            size: rangeToDiff(
              ((_b = caseNode.test) == null ? void 0 : _b.range) ??
                caseNode.range,
            ),
            node: caseNode,
            name,
          }
        })
        pairwise(nodes, (left, right, iteration) => {
          let compareValue
          let lefter = nodes.at(iteration - 1)
          let isCaseGrouped =
            (lefter == null ? void 0 : lefter.node.consequent.length) === 0 &&
            left.node.consequent.length !== 0
          let caseGroup = [left]
          for (let i = iteration - 1; i >= 0; i--) {
            if (nodes.at(i).node.consequent.length === 0) {
              caseGroup.unshift(nodes.at(i))
            } else {
              break
            }
          }
          if (left.name === 'default') {
            compareValue = true
          } else if (right.name === 'default') {
            compareValue = false
          } else if (isCaseGrouped) {
            compareValue = isPositive(compare(caseGroup[0], right, options))
          } else {
            compareValue = isPositive(compare(left, right, options))
          }
          if (compareValue) {
            context.report({
              messageId: 'unexpectedSwitchCaseOrder',
              data: {
                left: left.name,
                right: right.name,
              },
              node: right.node,
              fix: fixer => {
                let nodeGroups = nodes.reduce(
                  (accumulator, currentNode, index) => {
                    var _a
                    if (index === 0) {
                      accumulator.at(-1).push(currentNode)
                    } else if (
                      ((_a = accumulator.at(-1).at(-1)) == null
                        ? void 0
                        : _a.node.consequent.length) === 0
                    ) {
                      accumulator.at(-1).push(currentNode)
                    } else {
                      accumulator.push([currentNode])
                    }
                    return accumulator
                  },
                  [[]],
                )
                let sortedNodeGroups = nodeGroups
                  .map(group => {
                    let { consequent } = group.at(-1).node
                    group.at(-1).node.consequent = []
                    let sortedGroup = sortNodes(group, options)
                    sortedGroup.at(-1).node.consequent = consequent
                    return sortedGroup
                  })
                  .toSorted((a, b) => {
                    let isGroupContainsDefault = group =>
                      group.some(currentNode => currentNode.name === 'default')
                    if (isGroupContainsDefault(a)) {
                      return 1
                    } else if (isGroupContainsDefault(b)) {
                      return -1
                    }
                    return compare(a.at(0), b.at(0), options)
                  })
                let sortedNodes = sortedNodeGroups.flat()
                for (let i = 0, max = sortedNodes.length; i < max; i++) {
                  if (sortedNodes.at(i).name === 'default') {
                    sortedNodes.push(sortedNodes.splice(i, 1).at(0))
                  }
                }
                return makeFixes(fixer, nodes, sortedNodes, sourceCode)
              },
            })
          }
        })
      }
    },
  }),
})
export { sortSwitchCase as default }
