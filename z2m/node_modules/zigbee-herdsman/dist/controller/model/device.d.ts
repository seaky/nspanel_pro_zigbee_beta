import { Events as AdapterEvents } from '../../adapter';
import * as Zcl from '../../zspec/zcl';
import { ClusterDefinition, CustomClusters } from '../../zspec/zcl/definition/tstype';
import { KeyValue, DeviceType } from '../tstype';
import Endpoint from './endpoint';
import Entity from './entity';
interface LQI {
    neighbors: {
        ieeeAddr: string;
        networkAddress: number;
        linkquality: number;
        relationship: number;
        depth: number;
    }[];
}
interface RoutingTable {
    table: {
        destinationAddress: number;
        status: string;
        nextHop: number;
    }[];
}
type CustomReadResponse = (frame: Zcl.Frame, endpoint: Endpoint) => boolean;
declare class Device extends Entity {
    private readonly ID;
    private _applicationVersion?;
    private _dateCode?;
    private _endpoints;
    private _hardwareVersion?;
    private _ieeeAddr;
    private _interviewCompleted;
    private _interviewing;
    private _lastSeen;
    private _manufacturerID?;
    private _manufacturerName?;
    private _modelID?;
    private _networkAddress;
    private _powerSource?;
    private _softwareBuildID?;
    private _stackVersion?;
    private _type?;
    private _zclVersion?;
    private _linkquality?;
    private _skipDefaultResponse;
    private _customReadResponse?;
    private _lastDefaultResponseSequenceNumber;
    private _checkinInterval;
    private _pendingRequestTimeout;
    private _customClusters;
    get ieeeAddr(): string;
    set ieeeAddr(ieeeAddr: string);
    get applicationVersion(): number;
    set applicationVersion(applicationVersion: number);
    get endpoints(): Endpoint[];
    get interviewCompleted(): boolean;
    get interviewing(): boolean;
    get lastSeen(): number;
    get manufacturerID(): number;
    get isDeleted(): boolean;
    set type(type: DeviceType);
    get type(): DeviceType;
    get dateCode(): string;
    set dateCode(dateCode: string);
    set hardwareVersion(hardwareVersion: number);
    get hardwareVersion(): number;
    get manufacturerName(): string;
    set manufacturerName(manufacturerName: string);
    set modelID(modelID: string);
    get modelID(): string;
    get networkAddress(): number;
    set networkAddress(networkAddress: number);
    get powerSource(): string;
    set powerSource(powerSource: string);
    get softwareBuildID(): string;
    set softwareBuildID(softwareBuildID: string);
    get stackVersion(): number;
    set stackVersion(stackVersion: number);
    get zclVersion(): number;
    set zclVersion(zclVersion: number);
    get linkquality(): number;
    set linkquality(linkquality: number);
    get skipDefaultResponse(): boolean;
    set skipDefaultResponse(skipDefaultResponse: boolean);
    get customReadResponse(): CustomReadResponse;
    set customReadResponse(customReadResponse: CustomReadResponse);
    get checkinInterval(): number;
    set checkinInterval(checkinInterval: number);
    get pendingRequestTimeout(): number;
    set pendingRequestTimeout(pendingRequestTimeout: number);
    get customClusters(): CustomClusters;
    meta: KeyValue;
    private static devices;
    private static deletedDevices;
    static readonly ReportablePropertiesMapping: {
        [s: string]: {
            set: (value: string | number, device: Device) => void;
            key: 'modelID' | 'manufacturerName' | 'applicationVersion' | 'zclVersion' | 'powerSource' | 'stackVersion' | 'dateCode' | 'softwareBuildID' | 'hardwareVersion';
        };
    };
    private constructor();
    createEndpoint(ID: number): Endpoint;
    changeIeeeAddress(ieeeAddr: string): void;
    getEndpoint(ID: number): Endpoint;
    getEndpointByDeviceType(deviceType: string): Endpoint;
    implicitCheckin(): void;
    updateLastSeen(): void;
    private resetPendingRequestTimeout;
    private hasPendingRequests;
    onZclData(dataPayload: AdapterEvents.ZclPayload, frame: Zcl.Frame, endpoint: Endpoint): Promise<void>;
    /**
     * Reset runtime lookups.
     */
    static resetCache(): void;
    private static fromDatabaseEntry;
    private toDatabaseEntry;
    save(writeDatabase?: boolean): void;
    private static loadFromDatabaseIfNecessary;
    static find(ieeeOrNwkAddress: string | number, includeDeleted?: boolean): Device;
    static byIeeeAddr(ieeeAddr: string, includeDeleted?: boolean): Device;
    static byNetworkAddress(networkAddress: number, includeDeleted?: boolean): Device;
    static byType(type: DeviceType): Device[];
    static all(): Device[];
    static allIterator(predicate?: (value: Device) => boolean): Generator<Device>;
    undelete(interviewCompleted?: boolean): void;
    static create(type: DeviceType, ieeeAddr: string, networkAddress: number, manufacturerID: number, manufacturerName: string, powerSource: string, modelID: string, interviewCompleted: boolean, endpoints: {
        ID: number;
        profileID: number;
        deviceID: number;
        inputClusters: number[];
        outputClusters: number[];
    }[]): Device;
    interview(ignoreCache?: boolean): Promise<void>;
    private interviewQuirks;
    private interviewInternal;
    removeFromNetwork(): Promise<void>;
    removeFromDatabase(): void;
    lqi(): Promise<LQI>;
    routingTable(): Promise<RoutingTable>;
    ping(disableRecovery?: boolean): Promise<void>;
    addCustomCluster(name: string, cluster: ClusterDefinition): void;
}
export default Device;
//# sourceMappingURL=device.d.ts.map