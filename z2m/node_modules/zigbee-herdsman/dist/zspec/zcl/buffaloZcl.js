"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuffaloZcl = void 0;
const buffalo_1 = require("../../buffalo");
const utils_1 = require("../../utils");
const logger_1 = require("../../utils/logger");
const enums_1 = require("./definition/enums");
const Utils = __importStar(require("./utils"));
const NS = 'zh:zcl:buffalo';
const SEC_KEY_LENGTH = 16;
const EXTENSION_FIELD_SETS_DATA_TYPE = {
    6: [enums_1.DataType.UINT8],
    8: [enums_1.DataType.UINT8],
    258: [enums_1.DataType.UINT8, enums_1.DataType.UINT8],
    768: [enums_1.DataType.UINT16, enums_1.DataType.UINT16, enums_1.DataType.UINT16, enums_1.DataType.UINT8, enums_1.DataType.UINT8, enums_1.DataType.UINT8, enums_1.DataType.UINT16, enums_1.DataType.UINT16],
};
class BuffaloZcl extends buffalo_1.Buffalo {
    // TODO: remove read/write int "SB" versions in favor of plain numbers, implemented in buffalo.ts
    writeUInt40SB(value) {
        this.writeUInt32(value[1]);
        this.writeUInt8(value[0]);
    }
    readUInt40SB() {
        const lsb = this.readUInt32();
        const msb = this.readUInt8();
        return [msb, lsb];
    }
    writeUInt48SB(value) {
        this.writeUInt32(value[1]);
        this.writeUInt16(value[0]);
    }
    readUInt48SB() {
        const lsb = this.readUInt32();
        const msb = this.readUInt16();
        return [msb, lsb];
    }
    writeUInt56SB(value) {
        // XXX: [uint32, uint32] param not following read return pattern [uint32, uint16, uint8]
        const temp = Buffer.alloc(8);
        temp.writeUInt32LE(value[1], 0);
        temp.writeUInt32LE(value[0], 4);
        this.writeBuffer(temp.subarray(0, 7), 7);
    }
    readUInt56SB() {
        const lsb = this.readUInt32();
        const xsb = this.readUInt16();
        const msb = this.readUInt8();
        return [msb, xsb, lsb];
    }
    readUInt64SB() {
        // XXX: not following pattern, should return as [msb, lsb]
        return this.readIeeeAddr();
    }
    writeUInt64SB(value) {
        // XXX: not following pattern, should pass as number[uint32, uint32]
        const msb = parseInt(value.slice(2, 10), 16);
        const lsb = parseInt(value.slice(10), 16);
        this.writeUInt32(lsb);
        this.writeUInt32(msb);
    }
    writeInt40SB(value) {
        this.writeInt32(value[1]);
        this.writeInt8(value[0]);
    }
    readInt40SB() {
        const lsb = this.readInt32();
        const msb = this.readInt8();
        return [msb, lsb];
    }
    writeInt56SB(value) {
        const temp = Buffer.alloc(8);
        temp.writeInt32LE(value[1], 0);
        temp.writeInt32LE(value[0], 4);
        this.writeBuffer(temp.subarray(0, 7), 7);
    }
    readInt56SB() {
        const lsb = this.readInt32();
        const xsb = this.readInt16();
        const msb = this.readInt8();
        return [msb, xsb, lsb];
    }
    writeInt64SB(value) {
        this.writeInt32(value[1]);
        this.writeInt32(value[0]);
    }
    readInt64SB() {
        const lsb = this.readInt32();
        const msb = this.readInt32();
        return [msb, lsb];
    }
    writeOctetStr(value) {
        // TODO: this does not allow "non-value" 0xFF
        this.writeUInt8(value.length);
        this.writeBuffer(value, value.length);
    }
    readOctetStr() {
        const length = this.readUInt8();
        return length < 0xff ? this.readBuffer(length) : Buffer.from([]); // non-value
    }
    writeCharStr(value) {
        // TODO: this does not allow "non-value" 0xFF
        if (typeof value === 'string') {
            this.writeUInt8(value.length);
            this.writeUtf8String(value);
        }
        else {
            // XXX: value.length not written?
            this.writeBuffer(value, value.length);
        }
    }
    readCharStr() {
        const length = this.readUInt8();
        return length < 0xff ? this.readUtf8String(length) : '';
    }
    writeLongOctetStr(value) {
        // TODO: this does not allow "non-value" 0xFF
        this.writeUInt16(value.length);
        this.writeBuffer(value, value.length);
    }
    readLongOctetStr() {
        const length = this.readUInt16();
        return length < 0xffff ? this.readBuffer(length) : Buffer.from([]); // non-value
    }
    writeLongCharStr(value) {
        // TODO: this does not allow "non-value" 0xFF
        this.writeUInt16(value.length);
        this.writeUtf8String(value);
    }
    readLongCharStr() {
        const length = this.readUInt16();
        return length < 0xffff ? this.readUtf8String(length) : ''; // non-value
    }
    writeArray(value) {
        const elTypeNumeric = typeof value.elementType === 'number' ? value.elementType : enums_1.DataType[value.elementType];
        this.writeUInt8(elTypeNumeric);
        // TODO: this does not allow writing "non-value" 0xFFFF
        this.writeUInt16(value.elements.length);
        for (const element of value.elements) {
            this.write(elTypeNumeric, element, {});
        }
    }
    readArray() {
        const values = [];
        const elementType = this.readUInt8();
        const numberOfElements = this.readUInt16();
        if (numberOfElements < 0xffff) {
            for (let i = 0; i < numberOfElements; i++) {
                const value = this.read(elementType, {});
                values.push(value);
            }
        }
        return values;
    }
    writeStruct(value) {
        // XXX: from ZCL spec: "The zeroth element may not be written to."
        //      how does this translates to writing here?
        // TODO: this does not allow writing "non-value" 0xFFFF
        this.writeUInt16(value.length);
        for (const v of value) {
            this.writeUInt8(v.elmType);
            this.write(v.elmType, v.elmVal, {});
        }
    }
    readStruct() {
        const values = [];
        const numberOfElements = this.readUInt16();
        if (numberOfElements < 0xffff) {
            for (let i = 0; i < numberOfElements; i++) {
                const elementType = this.readUInt8();
                const value = this.read(elementType, {});
                values.push({ elmType: elementType, elmVal: value });
            }
        }
        return values;
    }
    writeToD(value) {
        this.writeUInt8(value.hours ?? 0xff);
        this.writeUInt8(value.minutes ?? 0xff);
        this.writeUInt8(value.seconds ?? 0xff);
        this.writeUInt8(value.hundredths ?? 0xff);
    }
    readToD() {
        const hours = this.readUInt8();
        const minutes = this.readUInt8();
        const seconds = this.readUInt8();
        const hundredths = this.readUInt8();
        return {
            hours: hours < 0xff ? hours : null,
            minutes: minutes < 0xff ? minutes : null,
            seconds: seconds < 0xff ? seconds : null,
            hundredths: hundredths < 0xff ? hundredths : null,
        };
    }
    writeDate(value) {
        this.writeUInt8(value.year != null ? value.year - 1900 : 0xff);
        this.writeUInt8(value.month ?? 0xff);
        this.writeUInt8(value.dayOfMonth ?? 0xff);
        this.writeUInt8(value.dayOfWeek ?? 0xff);
    }
    readDate() {
        const year = this.readUInt8();
        const month = this.readUInt8();
        const dayOfMonth = this.readUInt8();
        const dayOfWeek = this.readUInt8();
        return {
            year: year < 0xff ? year + 1900 : null,
            month: month < 0xff ? month : null,
            dayOfMonth: dayOfMonth < 0xff ? dayOfMonth : null,
            dayOfWeek: dayOfWeek < 0xff ? dayOfWeek : null,
        };
    }
    //--- BuffaloZclDataType
    writeListZoneInfo(values) {
        for (const value of values) {
            this.writeUInt8(value.zoneID);
            this.writeUInt16(value.zoneStatus);
        }
    }
    readListZoneInfo(length) {
        const value = [];
        for (let i = 0; i < length; i++) {
            value.push({
                zoneID: this.readUInt8(),
                zoneStatus: this.readUInt16(),
            });
        }
        return value;
    }
    writeExtensionFieldSets(values) {
        for (const value of values) {
            this.writeUInt16(value.clstId);
            this.writeUInt8(value.len);
            let index = 0;
            for (const entry of value.extField) {
                this.write(EXTENSION_FIELD_SETS_DATA_TYPE[value.clstId][index], entry, {});
                index++;
            }
        }
    }
    readExtensionFieldSets() {
        const value = [];
        // XXX: doesn't work if buffer has more unrelated fields after this one
        while (this.isMore()) {
            const clstId = this.readUInt16();
            const len = this.readUInt8();
            const end = this.getPosition() + len;
            let index = 0;
            const extField = [];
            while (this.getPosition() < end) {
                extField.push(this.read(EXTENSION_FIELD_SETS_DATA_TYPE[clstId][index], {}));
                index++;
            }
            value.push({ extField, clstId, len });
        }
        return value;
    }
    writeListThermoTransitions(value) {
        for (const entry of value) {
            this.writeUInt16(entry.transitionTime);
            if (entry.heatSetpoint != null) {
                this.writeUInt16(entry.heatSetpoint);
            }
            if (entry.coolSetpoint != null) {
                this.writeUInt16(entry.coolSetpoint);
            }
        }
    }
    readListThermoTransitions(options) {
        if (options.payload == null || options.payload.mode == null || options.payload.numoftrans == null) {
            throw new Error('Cannot read LIST_THERMO_TRANSITIONS without required payload options specified');
        }
        const heat = options.payload.mode & 1;
        const cool = options.payload.mode & 2;
        const result = [];
        for (let i = 0; i < options.payload.numoftrans; i++) {
            const entry = {
                transitionTime: this.readUInt16(),
            };
            if (heat) {
                entry.heatSetpoint = this.readUInt16();
            }
            if (cool) {
                entry.coolSetpoint = this.readUInt16();
            }
            result.push(entry);
        }
        return result;
    }
    writeGdpFrame(value) {
        if (value.commandID == 0xf0) {
            // Commissioning Reply
            const v = value;
            const panIDPresent = v.options & (1 << 0);
            const gpdSecurityKeyPresent = v.options & (1 << 1);
            const gpdKeyEncryption = v.options & (1 << 2);
            const securityLevel = v.options & ((3 << 3) >> 3);
            const hasGPDKeyMIC = gpdKeyEncryption && gpdSecurityKeyPresent;
            const hasFrameCounter = gpdSecurityKeyPresent && gpdKeyEncryption && (securityLevel === 0b10 || securityLevel === 0b11);
            this.writeUInt8(1 + (panIDPresent ? 2 : 0) + (gpdSecurityKeyPresent ? 16 : 0) + (hasGPDKeyMIC ? 4 : 0) + (hasFrameCounter ? 4 : 0)); // Length
            this.writeUInt8(v.options);
            if (panIDPresent) {
                this.writeUInt16(v.panID);
            }
            if (gpdSecurityKeyPresent) {
                this.writeBuffer(v.securityKey, 16);
            }
            if (hasGPDKeyMIC) {
                this.writeUInt32(v.keyMic);
            }
            if (hasFrameCounter) {
                this.writeUInt32(v.frameCounter);
            }
        }
        else if (value.commandID == 0xf3) {
            // Channel configuration
            const v = value;
            this.writeUInt8(1);
            this.writeUInt8((v.operationalChannel & 0xf) | ((v.basic ? 1 : 0) << 4));
        }
        else if (value.commandID == 0xf4 || value.commandID == 0xf5 || (value.commandID >= 0xf7 && value.commandID <= 0xff)) {
            // Other commands sent to GPD
            const v = value;
            this.writeUInt8(v.buffer.length);
            this.writeBuffer(v.buffer, v.buffer.length);
        }
    }
    readGdpFrame(options) {
        // Commisioning
        if (options.payload?.commandID === 0xe0) {
            const frame = {
                deviceID: this.readUInt8(),
                options: this.readUInt8(),
                extendedOptions: 0,
                securityKey: Buffer.alloc(16),
                keyMic: 0,
                outgoingCounter: 0,
                applicationInfo: 0,
                manufacturerID: 0,
                modelID: 0,
                numGdpCommands: 0,
                gpdCommandIdList: Buffer.alloc(0),
                numServerClusters: 0,
                numClientClusters: 0,
                gpdServerClusters: Buffer.alloc(0),
                gpdClientClusters: Buffer.alloc(0),
            };
            if (frame.options & 0x80) {
                frame.extendedOptions = this.readUInt8();
            }
            if (frame.extendedOptions & 0x20) {
                frame.securityKey = this.readBuffer(16);
            }
            if (frame.extendedOptions & 0x40) {
                frame.keyMic = this.readUInt32();
            }
            if (frame.extendedOptions & 0x80) {
                frame.outgoingCounter = this.readUInt32();
            }
            if (frame.options & 0x04) {
                frame.applicationInfo = this.readUInt8();
            }
            if (frame.applicationInfo & 0x01) {
                frame.manufacturerID = this.readUInt16();
            }
            if (frame.applicationInfo & 0x02) {
                frame.modelID = this.readUInt16();
            }
            if (frame.applicationInfo & 0x04) {
                frame.numGdpCommands = this.readUInt8();
                frame.gpdCommandIdList = this.readBuffer(frame.numGdpCommands);
            }
            if (frame.applicationInfo & 0x08) {
                const len = this.readUInt8();
                frame.numServerClusters = len & 0xf;
                frame.numClientClusters = (len >> 4) & 0xf;
                frame.gpdServerClusters = this.readBuffer(2 * frame.numServerClusters);
                frame.gpdClientClusters = this.readBuffer(2 * frame.numClientClusters);
            }
            return frame;
            // Channel Request
        }
        else if (options.payload?.commandID === 0xe3) {
            const options = this.readUInt8();
            return {
                nextChannel: options & 0xf,
                nextNextChannel: options >> 4,
            };
            // Manufacturer-specific Attribute Reporting
        }
        else if (options.payload?.commandID == 0xa1) {
            if (options.payload.payloadSize == null) {
                throw new Error('Cannot read GDP_FRAME with commandID=0xA1 without payloadSize options specified');
            }
            const start = this.position;
            const frame = {
                manufacturerCode: this.readUInt16(),
                clusterID: this.readUInt16(),
                attributes: {},
            };
            const cluster = Utils.getCluster(frame.clusterID, frame.manufacturerCode, {});
            while (this.position - start < options.payload.payloadSize) {
                const attributeID = this.readUInt16();
                const type = this.readUInt8();
                let attribute = attributeID;
                try {
                    attribute = cluster.getAttribute(attributeID).name;
                }
                catch {
                    // this is spammy because of the many manufacturer-specific attributes not currently used
                    logger_1.logger.debug('Unknown attribute ' + attributeID + ' in cluster ' + cluster.name, NS);
                }
                frame.attributes[attribute] = this.read(type, options);
            }
            return frame;
        }
        else if (this.isMore()) {
            return { raw: this.buffer.subarray(this.position) };
        }
        else {
            return {};
        }
    }
    writeStructuredSelector(value) {
        if (value != null) {
            const indexes = value.indexes || [];
            const indicatorType = value.indicatorType || enums_1.StructuredIndicatorType.Whole;
            const indicator = indexes.length + indicatorType;
            this.writeUInt8(indicator);
            for (const index of indexes) {
                this.writeUInt16(index);
            }
        }
    }
    readStructuredSelector() {
        /** [0-15] range */
        const indicator = this.readUInt8();
        if (indicator === 0) {
            // no indexes, whole attribute value is to be read
            return { indicatorType: enums_1.StructuredIndicatorType.Whole };
        }
        else if (indicator < enums_1.StructuredIndicatorType.WriteAdd) {
            const indexes = [];
            for (let i = 0; i < indicator; i++) {
                const index = this.readUInt16();
                indexes.push(index);
            }
            return { indexes };
        }
        else {
            throw new Error(`Read structured selector was outside [0-15] range.`);
        }
    }
    writeListTuyaDataPointValues(dpValues) {
        for (const dpValue of dpValues) {
            this.writeUInt8(dpValue.dp);
            this.writeUInt8(dpValue.datatype);
            const dataLen = dpValue.data.length;
            // UInt16BE
            this.writeUInt8((dataLen >> 8) & 0xff);
            this.writeUInt8(dataLen & 0xff);
            this.writeBuffer(dpValue.data, dataLen);
        }
    }
    readListTuyaDataPointValues() {
        const value = [];
        // XXX: doesn't work if buffer has more unrelated fields after this one
        while (this.isMore()) {
            try {
                const dp = this.readUInt8();
                const datatype = this.readUInt8();
                const len_hi = this.readUInt8();
                const len_lo = this.readUInt8();
                const data = this.readBuffer(len_lo + (len_hi << 8));
                value.push({ dp, datatype, data });
            }
            catch (error) {
                break;
            }
        }
        return value;
    }
    writeListMiboxerZones(values) {
        this.writeUInt8(values.length);
        for (const value of values) {
            this.writeUInt16(value.groupId);
            this.writeUInt8(value.zoneNum);
        }
    }
    readListMiboxerZones() {
        const value = [];
        const len = this.readUInt8();
        for (let i = 0; i < len; i++) {
            const groupId = this.readUInt16();
            const zoneNum = this.readUInt8();
            value.push({ groupId, zoneNum });
        }
        return value;
    }
    writeBigEndianUInt24(value) {
        this.buffer.writeUIntBE(value, this.position, 3);
        this.position += 3;
    }
    readBigEndianUInt24() {
        const value = this.buffer.readUIntBE(this.position, 3);
        this.position += 3;
        return value;
    }
    // private writeMiStruct(value: Record<number, number | number[]>): {
    //     XXX: read only?
    // }
    readMiStruct() {
        const length = this.readUInt8();
        const value = {};
        if (length === 0xff) {
            return value;
        }
        for (let i = 0; i < length; i++) {
            const index = this.readUInt8();
            const dataType = this.readUInt8();
            value[index] = this.read(dataType, {});
            if (this.position === this.buffer.length) {
                break;
            }
        }
        return value;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    write(type, value, options) {
        switch (type) {
            case enums_1.DataType.NO_DATA:
            case enums_1.DataType.UNKNOWN: {
                return; // nothing to write
            }
            case enums_1.DataType.DATA8:
            case enums_1.DataType.BOOLEAN:
            case enums_1.DataType.BITMAP8:
            case enums_1.DataType.UINT8:
            case enums_1.DataType.ENUM8: {
                return this.writeUInt8(value);
            }
            case enums_1.DataType.DATA16:
            case enums_1.DataType.BITMAP16:
            case enums_1.DataType.UINT16:
            case enums_1.DataType.ENUM16:
            case enums_1.DataType.CLUSTER_ID:
            case enums_1.DataType.ATTR_ID: {
                return this.writeUInt16(value);
            }
            case enums_1.DataType.DATA24:
            case enums_1.DataType.BITMAP24:
            case enums_1.DataType.UINT24: {
                return this.writeUInt24(value);
            }
            case enums_1.DataType.DATA32:
            case enums_1.DataType.BITMAP32:
            case enums_1.DataType.UINT32:
            case enums_1.DataType.UTC:
            case enums_1.DataType.BAC_OID: {
                return this.writeUInt32(value);
            }
            case enums_1.DataType.DATA40:
            case enums_1.DataType.BITMAP40:
            case enums_1.DataType.UINT40: {
                return this.writeUInt40SB(value);
            }
            case enums_1.DataType.DATA48:
            case enums_1.DataType.BITMAP48:
            case enums_1.DataType.UINT48: {
                return this.writeUInt48SB(value);
            }
            case enums_1.DataType.DATA56:
            case enums_1.DataType.BITMAP56:
            case enums_1.DataType.UINT56: {
                return this.writeUInt56SB(value);
            }
            case enums_1.DataType.DATA64:
            case enums_1.DataType.BITMAP64:
            case enums_1.DataType.UINT64: {
                return this.writeUInt64SB(value);
            }
            case enums_1.DataType.INT8: {
                return this.writeInt8(value);
            }
            case enums_1.DataType.INT16: {
                return this.writeInt16(value);
            }
            case enums_1.DataType.INT24: {
                return this.writeInt24(value);
            }
            case enums_1.DataType.INT32: {
                return this.writeInt32(value);
            }
            case enums_1.DataType.INT40: {
                return this.writeInt40SB(value);
            }
            case enums_1.DataType.INT48: {
                return this.writeInt48(value);
            }
            case enums_1.DataType.INT56: {
                return this.writeInt56SB(value);
            }
            case enums_1.DataType.INT64: {
                return this.writeInt64SB(value);
            }
            // case DataType.SEMI_PREC: {
            //     // https://tc39.es/proposal-float16array/
            //     // not currently used
            //     return this.writeSemiFloatLE(value);
            // }
            case enums_1.DataType.SINGLE_PREC: {
                return this.writeFloatLE(value);
            }
            case enums_1.DataType.DOUBLE_PREC: {
                return this.writeDoubleLE(value);
            }
            case enums_1.DataType.OCTET_STR: {
                return this.writeOctetStr(value);
            }
            case enums_1.DataType.CHAR_STR: {
                return this.writeCharStr(value);
            }
            case enums_1.DataType.LONG_OCTET_STR: {
                return this.writeLongOctetStr(value);
            }
            case enums_1.DataType.LONG_CHAR_STR: {
                return this.writeLongCharStr(value);
            }
            case enums_1.DataType.ARRAY:
            case enums_1.DataType.SET:
            case enums_1.DataType.BAG: {
                return this.writeArray(value);
            }
            case enums_1.DataType.STRUCT: {
                return this.writeStruct(value);
            }
            case enums_1.DataType.TOD: {
                return this.writeToD(value);
            }
            case enums_1.DataType.DATE: {
                return this.writeDate(value);
            }
            case enums_1.DataType.IEEE_ADDR: {
                return this.writeIeeeAddr(value);
            }
            case enums_1.DataType.SEC_KEY: {
                return this.writeBuffer(value, SEC_KEY_LENGTH);
            }
            case enums_1.BuffaloZclDataType.USE_DATA_TYPE: {
                if (options.dataType == null) {
                    if (Buffer.isBuffer(value) || (0, utils_1.IsNumberArray)(value)) {
                        return this.writeBuffer(value, value.length);
                    }
                    else {
                        throw new Error('Cannot write USE_DATA_TYPE without dataType option specified');
                    }
                }
                return this.write(options.dataType, value, options);
            }
            case enums_1.BuffaloZclDataType.LIST_UINT8: {
                return this.writeListUInt8(value);
            }
            case enums_1.BuffaloZclDataType.LIST_UINT16: {
                return this.writeListUInt16(value);
            }
            case enums_1.BuffaloZclDataType.LIST_UINT24: {
                return this.writeListUInt24(value);
            }
            case enums_1.BuffaloZclDataType.LIST_UINT32: {
                return this.writeListUInt32(value);
            }
            case enums_1.BuffaloZclDataType.LIST_ZONEINFO: {
                return this.writeListZoneInfo(value);
            }
            case enums_1.BuffaloZclDataType.EXTENSION_FIELD_SETS: {
                return this.writeExtensionFieldSets(value);
            }
            case enums_1.BuffaloZclDataType.LIST_THERMO_TRANSITIONS: {
                return this.writeListThermoTransitions(value);
            }
            case enums_1.BuffaloZclDataType.BUFFER: {
                // XXX: inconsistent with read that allows partial with options.length, here always "whole"
                return this.writeBuffer(value, value.length);
            }
            case enums_1.BuffaloZclDataType.GDP_FRAME: {
                return this.writeGdpFrame(value);
            }
            case enums_1.BuffaloZclDataType.STRUCTURED_SELECTOR: {
                return this.writeStructuredSelector(value);
            }
            case enums_1.BuffaloZclDataType.LIST_TUYA_DATAPOINT_VALUES: {
                return this.writeListTuyaDataPointValues(value);
            }
            case enums_1.BuffaloZclDataType.LIST_MIBOXER_ZONES: {
                return this.writeListMiboxerZones(value);
            }
            case enums_1.BuffaloZclDataType.BIG_ENDIAN_UINT24: {
                return this.writeBigEndianUInt24(value);
            }
            default: {
                // In case the type is undefined, write it as a buffer to easily allow for custom types
                // e.g. for https://github.com/Koenkk/zigbee-herdsman/issues/127
                if (Buffer.isBuffer(value) || (0, utils_1.IsNumberArray)(value)) {
                    return this.writeBuffer(value, value.length);
                }
            }
        }
        throw new Error(`Write for '${type}' not available`);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    read(type, options) {
        switch (type) {
            case enums_1.DataType.NO_DATA:
            case enums_1.DataType.UNKNOWN: {
                return; // nothing to write
            }
            case enums_1.DataType.DATA8:
            case enums_1.DataType.BOOLEAN:
            case enums_1.DataType.BITMAP8:
            case enums_1.DataType.UINT8:
            case enums_1.DataType.ENUM8: {
                return this.readUInt8();
            }
            case enums_1.DataType.DATA16:
            case enums_1.DataType.BITMAP16:
            case enums_1.DataType.UINT16:
            case enums_1.DataType.ENUM16:
            case enums_1.DataType.CLUSTER_ID:
            case enums_1.DataType.ATTR_ID: {
                return this.readUInt16();
            }
            case enums_1.DataType.DATA24:
            case enums_1.DataType.BITMAP24:
            case enums_1.DataType.UINT24: {
                return this.readUInt24();
            }
            case enums_1.DataType.DATA32:
            case enums_1.DataType.BITMAP32:
            case enums_1.DataType.UINT32:
            case enums_1.DataType.UTC:
            case enums_1.DataType.BAC_OID: {
                return this.readUInt32();
            }
            case enums_1.DataType.DATA40:
            case enums_1.DataType.BITMAP40:
            case enums_1.DataType.UINT40: {
                return this.readUInt40SB();
            }
            case enums_1.DataType.DATA48:
            case enums_1.DataType.BITMAP48:
            case enums_1.DataType.UINT48: {
                return this.readUInt48SB();
            }
            case enums_1.DataType.DATA56:
            case enums_1.DataType.BITMAP56:
            case enums_1.DataType.UINT56: {
                return this.readUInt56SB();
            }
            case enums_1.DataType.DATA64:
            case enums_1.DataType.BITMAP64:
            case enums_1.DataType.UINT64: {
                return this.readUInt64SB();
            }
            case enums_1.DataType.INT8: {
                return this.readInt8();
            }
            case enums_1.DataType.INT16: {
                return this.readInt16();
            }
            case enums_1.DataType.INT24: {
                return this.readInt24();
            }
            case enums_1.DataType.INT32: {
                return this.readInt32();
            }
            case enums_1.DataType.INT40: {
                return this.readInt40SB();
            }
            case enums_1.DataType.INT48: {
                return this.readInt48();
            }
            case enums_1.DataType.INT56: {
                return this.readInt56SB();
            }
            case enums_1.DataType.INT64: {
                return this.readInt64SB();
            }
            // case DataType.SEMI_PREC: {
            //     // https://tc39.es/proposal-float16array/
            //     // not currently used
            //     return this.readSemiFloatLE();
            // }
            case enums_1.DataType.SINGLE_PREC: {
                return this.readFloatLE();
            }
            case enums_1.DataType.DOUBLE_PREC: {
                return this.readDoubleLE();
            }
            case enums_1.DataType.OCTET_STR: {
                return this.readOctetStr();
            }
            case enums_1.DataType.CHAR_STR: {
                return this.readCharStr();
            }
            case enums_1.DataType.LONG_OCTET_STR: {
                return this.readLongOctetStr();
            }
            case enums_1.DataType.LONG_CHAR_STR: {
                return this.readLongCharStr();
            }
            case enums_1.DataType.ARRAY:
            case enums_1.DataType.SET:
            case enums_1.DataType.BAG: {
                return this.readArray();
            }
            case enums_1.DataType.STRUCT: {
                return this.readStruct();
            }
            case enums_1.DataType.TOD: {
                return this.readToD();
            }
            case enums_1.DataType.DATE: {
                return this.readDate();
            }
            case enums_1.DataType.IEEE_ADDR: {
                return this.readIeeeAddr();
            }
            case enums_1.DataType.SEC_KEY: {
                return this.readBuffer(SEC_KEY_LENGTH);
            }
            case enums_1.BuffaloZclDataType.USE_DATA_TYPE: {
                if (options.dataType == null) {
                    return this.readBuffer(options.length ?? this.buffer.length);
                }
                return this.read(options.dataType, options);
            }
            case enums_1.BuffaloZclDataType.LIST_UINT8: {
                if (options.length == null) {
                    throw new Error('Cannot read LIST_UINT8 without length option specified');
                }
                return this.readListUInt8(options.length);
            }
            case enums_1.BuffaloZclDataType.LIST_UINT16: {
                if (options.length == null) {
                    throw new Error('Cannot read LIST_UINT16 without length option specified');
                }
                return this.readListUInt16(options.length);
            }
            case enums_1.BuffaloZclDataType.LIST_UINT24: {
                if (options.length == null) {
                    throw new Error('Cannot read LIST_UINT24 without length option specified');
                }
                return this.readListUInt24(options.length);
            }
            case enums_1.BuffaloZclDataType.LIST_UINT32: {
                if (options.length == null) {
                    throw new Error('Cannot read LIST_UINT32 without length option specified');
                }
                return this.readListUInt32(options.length);
            }
            case enums_1.BuffaloZclDataType.LIST_ZONEINFO: {
                if (options.length == null) {
                    throw new Error('Cannot read LIST_ZONEINFO without length option specified');
                }
                return this.readListZoneInfo(options.length);
            }
            case enums_1.BuffaloZclDataType.EXTENSION_FIELD_SETS: {
                return this.readExtensionFieldSets();
            }
            case enums_1.BuffaloZclDataType.LIST_THERMO_TRANSITIONS: {
                return this.readListThermoTransitions(options);
            }
            case enums_1.BuffaloZclDataType.BUFFER: {
                // if length option not specified, read the whole buffer
                return this.readBuffer(options.length ?? this.buffer.length);
            }
            case enums_1.BuffaloZclDataType.GDP_FRAME: {
                return this.readGdpFrame(options);
            }
            case enums_1.BuffaloZclDataType.STRUCTURED_SELECTOR: {
                return this.readStructuredSelector();
            }
            case enums_1.BuffaloZclDataType.LIST_TUYA_DATAPOINT_VALUES: {
                return this.readListTuyaDataPointValues();
            }
            case enums_1.BuffaloZclDataType.LIST_MIBOXER_ZONES: {
                return this.readListMiboxerZones();
            }
            case enums_1.BuffaloZclDataType.BIG_ENDIAN_UINT24: {
                return this.readBigEndianUInt24();
            }
            case enums_1.BuffaloZclDataType.MI_STRUCT: {
                return this.readMiStruct();
            }
        }
        throw new Error(`Read for '${type}' not available`);
    }
}
exports.BuffaloZcl = BuffaloZcl;
//# sourceMappingURL=buffaloZcl.js.map